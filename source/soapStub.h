/* soapStub.h
   Generated by gSOAP 2.8.70 for weather.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://WebXml.com.cn/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20870
# error "GSOAP VERSION 20870 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns1__ArrayOfString;	/* weather.h:168 */
class _ns1__getRegionDataset;	/* weather.h:171 */
class _ns1__getRegionDatasetResponse_getRegionDatasetResult;	/* weather.h:287 */
class _ns1__getRegionDatasetResponse;	/* weather.h:174 */
class _ns1__getRegionProvince;	/* weather.h:177 */
class _ns1__getRegionProvinceResponse;	/* weather.h:180 */
class _ns1__getRegionCountry;	/* weather.h:183 */
class _ns1__getRegionCountryResponse;	/* weather.h:186 */
class _ns1__getSupportCityDataset;	/* weather.h:189 */
class _ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult;	/* weather.h:423 */
class _ns1__getSupportCityDatasetResponse;	/* weather.h:192 */
class _ns1__getSupportCityString;	/* weather.h:195 */
class _ns1__getSupportCityStringResponse;	/* weather.h:198 */
class _ns1__getWeather;	/* weather.h:201 */
class _ns1__getWeatherResponse;	/* weather.h:204 */
class _ns1__DataSet;	/* weather.h:207 */
struct __ns1__getRegionDataset;	/* weather.h:748 */
struct __ns1__getRegionProvince;	/* weather.h:820 */
struct __ns1__getRegionCountry;	/* weather.h:892 */
struct __ns1__getSupportCityDataset;	/* weather.h:964 */
struct __ns1__getSupportCityString;	/* weather.h:1036 */
struct __ns1__getWeather;	/* weather.h:1108 */
struct __ns1__getRegionDataset_;	/* weather.h:1180 */
struct __ns1__getRegionProvince_;	/* weather.h:1252 */
struct __ns1__getRegionCountry_;	/* weather.h:1324 */
struct __ns1__getSupportCityDataset_;	/* weather.h:1396 */
struct __ns1__getSupportCityString_;	/* weather.h:1468 */
struct __ns1__getWeather_;	/* weather.h:1540 */

/* weather.h:168 */
#ifndef SOAP_TYPE_ns1__ArrayOfString
#define SOAP_TYPE_ns1__ArrayOfString (9)
/* complex XSD type 'ns1:ArrayOfString': */
class SOAP_CMAC ns1__ArrayOfString {
      public:
        /// Optional element 'ns1:string' of XSD type 'xsd:string'
        std::vector<std::wstring> string;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfString
        virtual long soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfString; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfString, default initialized and not managed by a soap context
        virtual ns1__ArrayOfString *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns1__ArrayOfString); }
      public:
        /// Constructor with initializations
        ns1__ArrayOfString() : string(), soap() { }
        virtual ~ns1__ArrayOfString() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfString(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfString * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:171 */
#ifndef SOAP_TYPE__ns1__getRegionDataset
#define SOAP_TYPE__ns1__getRegionDataset (10)
/* complex XSD type 'ns1:getRegionDataset': */
class SOAP_CMAC _ns1__getRegionDataset {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getRegionDataset
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getRegionDataset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getRegionDataset, default initialized and not managed by a soap context
        virtual _ns1__getRegionDataset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getRegionDataset); }
      public:
        /// Constructor with initializations
        _ns1__getRegionDataset() : soap() { }
        virtual ~_ns1__getRegionDataset() { }
        /// Friend allocator used by soap_new__ns1__getRegionDataset(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getRegionDataset * SOAP_FMAC2 soap_instantiate__ns1__getRegionDataset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:287 */
#ifndef SOAP_TYPE__ns1__getRegionDatasetResponse_getRegionDatasetResult
#define SOAP_TYPE__ns1__getRegionDatasetResponse_getRegionDatasetResult (26)
/* complex XSD type 'ns1:getRegionDatasetResponse-getRegionDatasetResult': */
class SOAP_CMAC _ns1__getRegionDatasetResponse_getRegionDatasetResult {
      public:
        /// Required element 'xsd:schema' of XSD type 'xsd:anyType'
        char *xsd__schema;
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getRegionDatasetResponse_getRegionDatasetResult
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getRegionDatasetResponse_getRegionDatasetResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getRegionDatasetResponse_getRegionDatasetResult, default initialized and not managed by a soap context
        virtual _ns1__getRegionDatasetResponse_getRegionDatasetResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getRegionDatasetResponse_getRegionDatasetResult); }
      public:
        /// Constructor with initializations
        _ns1__getRegionDatasetResponse_getRegionDatasetResult() : xsd__schema(), __any() { }
        virtual ~_ns1__getRegionDatasetResponse_getRegionDatasetResult() { }
        /// Friend allocator used by soap_new__ns1__getRegionDatasetResponse_getRegionDatasetResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getRegionDatasetResponse_getRegionDatasetResult * SOAP_FMAC2 soap_instantiate__ns1__getRegionDatasetResponse_getRegionDatasetResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:174 */
#ifndef SOAP_TYPE__ns1__getRegionDatasetResponse
#define SOAP_TYPE__ns1__getRegionDatasetResponse (11)
/* complex XSD type 'ns1:getRegionDatasetResponse': */
class SOAP_CMAC _ns1__getRegionDatasetResponse {
      public:
        /// Optional element 'ns1:getRegionDatasetResult' of XSD type 'ns1:getRegionDatasetResponse-getRegionDatasetResult'
        _ns1__getRegionDatasetResponse_getRegionDatasetResult *getRegionDatasetResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getRegionDatasetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getRegionDatasetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getRegionDatasetResponse, default initialized and not managed by a soap context
        virtual _ns1__getRegionDatasetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getRegionDatasetResponse); }
      public:
        /// Constructor with initializations
        _ns1__getRegionDatasetResponse() : getRegionDatasetResult(), soap() { }
        virtual ~_ns1__getRegionDatasetResponse() { }
        /// Friend allocator used by soap_new__ns1__getRegionDatasetResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getRegionDatasetResponse * SOAP_FMAC2 soap_instantiate__ns1__getRegionDatasetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:177 */
#ifndef SOAP_TYPE__ns1__getRegionProvince
#define SOAP_TYPE__ns1__getRegionProvince (12)
/* complex XSD type 'ns1:getRegionProvince': */
class SOAP_CMAC _ns1__getRegionProvince {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getRegionProvince
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getRegionProvince; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getRegionProvince, default initialized and not managed by a soap context
        virtual _ns1__getRegionProvince *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getRegionProvince); }
      public:
        /// Constructor with initializations
        _ns1__getRegionProvince() : soap() { }
        virtual ~_ns1__getRegionProvince() { }
        /// Friend allocator used by soap_new__ns1__getRegionProvince(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getRegionProvince * SOAP_FMAC2 soap_instantiate__ns1__getRegionProvince(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:180 */
#ifndef SOAP_TYPE__ns1__getRegionProvinceResponse
#define SOAP_TYPE__ns1__getRegionProvinceResponse (13)
/* complex XSD type 'ns1:getRegionProvinceResponse': */
class SOAP_CMAC _ns1__getRegionProvinceResponse {
      public:
        /// Optional element 'ns1:getRegionProvinceResult' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *getRegionProvinceResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getRegionProvinceResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getRegionProvinceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getRegionProvinceResponse, default initialized and not managed by a soap context
        virtual _ns1__getRegionProvinceResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getRegionProvinceResponse); }
      public:
        /// Constructor with initializations
        _ns1__getRegionProvinceResponse() : getRegionProvinceResult(), soap() { }
        virtual ~_ns1__getRegionProvinceResponse() { }
        /// Friend allocator used by soap_new__ns1__getRegionProvinceResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getRegionProvinceResponse * SOAP_FMAC2 soap_instantiate__ns1__getRegionProvinceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:183 */
#ifndef SOAP_TYPE__ns1__getRegionCountry
#define SOAP_TYPE__ns1__getRegionCountry (14)
/* complex XSD type 'ns1:getRegionCountry': */
class SOAP_CMAC _ns1__getRegionCountry {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getRegionCountry
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getRegionCountry; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getRegionCountry, default initialized and not managed by a soap context
        virtual _ns1__getRegionCountry *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getRegionCountry); }
      public:
        /// Constructor with initializations
        _ns1__getRegionCountry() : soap() { }
        virtual ~_ns1__getRegionCountry() { }
        /// Friend allocator used by soap_new__ns1__getRegionCountry(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getRegionCountry * SOAP_FMAC2 soap_instantiate__ns1__getRegionCountry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:186 */
#ifndef SOAP_TYPE__ns1__getRegionCountryResponse
#define SOAP_TYPE__ns1__getRegionCountryResponse (15)
/* complex XSD type 'ns1:getRegionCountryResponse': */
class SOAP_CMAC _ns1__getRegionCountryResponse {
      public:
        /// Optional element 'ns1:getRegionCountryResult' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *getRegionCountryResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getRegionCountryResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getRegionCountryResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getRegionCountryResponse, default initialized and not managed by a soap context
        virtual _ns1__getRegionCountryResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getRegionCountryResponse); }
      public:
        /// Constructor with initializations
        _ns1__getRegionCountryResponse() : getRegionCountryResult(), soap() { }
        virtual ~_ns1__getRegionCountryResponse() { }
        /// Friend allocator used by soap_new__ns1__getRegionCountryResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getRegionCountryResponse * SOAP_FMAC2 soap_instantiate__ns1__getRegionCountryResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:189 */
#ifndef SOAP_TYPE__ns1__getSupportCityDataset
#define SOAP_TYPE__ns1__getSupportCityDataset (16)
/* complex XSD type 'ns1:getSupportCityDataset': */
class SOAP_CMAC _ns1__getSupportCityDataset {
      public:
        /// Optional element 'ns1:theRegionCode' of XSD type 'xsd:string'
        std::wstring *theRegionCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getSupportCityDataset
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getSupportCityDataset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getSupportCityDataset, default initialized and not managed by a soap context
        virtual _ns1__getSupportCityDataset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getSupportCityDataset); }
      public:
        /// Constructor with initializations
        _ns1__getSupportCityDataset() : theRegionCode(), soap() { }
        virtual ~_ns1__getSupportCityDataset() { }
        /// Friend allocator used by soap_new__ns1__getSupportCityDataset(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getSupportCityDataset * SOAP_FMAC2 soap_instantiate__ns1__getSupportCityDataset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:423 */
#ifndef SOAP_TYPE__ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult
#define SOAP_TYPE__ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult (30)
/* complex XSD type 'ns1:getSupportCityDatasetResponse-getSupportCityDatasetResult': */
class SOAP_CMAC _ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult {
      public:
        /// Required element 'xsd:schema' of XSD type 'xsd:anyType'
        char *xsd__schema;
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult, default initialized and not managed by a soap context
        virtual _ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult); }
      public:
        /// Constructor with initializations
        _ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult() : xsd__schema(), __any() { }
        virtual ~_ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult() { }
        /// Friend allocator used by soap_new__ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult * SOAP_FMAC2 soap_instantiate__ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:192 */
#ifndef SOAP_TYPE__ns1__getSupportCityDatasetResponse
#define SOAP_TYPE__ns1__getSupportCityDatasetResponse (17)
/* complex XSD type 'ns1:getSupportCityDatasetResponse': */
class SOAP_CMAC _ns1__getSupportCityDatasetResponse {
      public:
        /// Optional element 'ns1:getSupportCityDatasetResult' of XSD type 'ns1:getSupportCityDatasetResponse-getSupportCityDatasetResult'
        _ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult *getSupportCityDatasetResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getSupportCityDatasetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getSupportCityDatasetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getSupportCityDatasetResponse, default initialized and not managed by a soap context
        virtual _ns1__getSupportCityDatasetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getSupportCityDatasetResponse); }
      public:
        /// Constructor with initializations
        _ns1__getSupportCityDatasetResponse() : getSupportCityDatasetResult(), soap() { }
        virtual ~_ns1__getSupportCityDatasetResponse() { }
        /// Friend allocator used by soap_new__ns1__getSupportCityDatasetResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getSupportCityDatasetResponse * SOAP_FMAC2 soap_instantiate__ns1__getSupportCityDatasetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:195 */
#ifndef SOAP_TYPE__ns1__getSupportCityString
#define SOAP_TYPE__ns1__getSupportCityString (18)
/* complex XSD type 'ns1:getSupportCityString': */
class SOAP_CMAC _ns1__getSupportCityString {
      public:
        /// Optional element 'ns1:theRegionCode' of XSD type 'xsd:string'
        std::wstring *theRegionCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getSupportCityString
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getSupportCityString; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getSupportCityString, default initialized and not managed by a soap context
        virtual _ns1__getSupportCityString *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getSupportCityString); }
      public:
        /// Constructor with initializations
        _ns1__getSupportCityString() : theRegionCode(), soap() { }
        virtual ~_ns1__getSupportCityString() { }
        /// Friend allocator used by soap_new__ns1__getSupportCityString(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getSupportCityString * SOAP_FMAC2 soap_instantiate__ns1__getSupportCityString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:198 */
#ifndef SOAP_TYPE__ns1__getSupportCityStringResponse
#define SOAP_TYPE__ns1__getSupportCityStringResponse (19)
/* complex XSD type 'ns1:getSupportCityStringResponse': */
class SOAP_CMAC _ns1__getSupportCityStringResponse {
      public:
        /// Optional element 'ns1:getSupportCityStringResult' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *getSupportCityStringResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getSupportCityStringResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getSupportCityStringResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getSupportCityStringResponse, default initialized and not managed by a soap context
        virtual _ns1__getSupportCityStringResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getSupportCityStringResponse); }
      public:
        /// Constructor with initializations
        _ns1__getSupportCityStringResponse() : getSupportCityStringResult(), soap() { }
        virtual ~_ns1__getSupportCityStringResponse() { }
        /// Friend allocator used by soap_new__ns1__getSupportCityStringResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getSupportCityStringResponse * SOAP_FMAC2 soap_instantiate__ns1__getSupportCityStringResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:201 */
#ifndef SOAP_TYPE__ns1__getWeather
#define SOAP_TYPE__ns1__getWeather (20)
/* complex XSD type 'ns1:getWeather': */
class SOAP_CMAC _ns1__getWeather {
      public:
        /// Optional element 'ns1:theCityCode' of XSD type 'xsd:string'
        std::wstring *theCityCode;
        /// Optional element 'ns1:theUserID' of XSD type 'xsd:string'
        std::wstring *theUserID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getWeather
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getWeather; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getWeather, default initialized and not managed by a soap context
        virtual _ns1__getWeather *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getWeather); }
      public:
        /// Constructor with initializations
        _ns1__getWeather() : theCityCode(), theUserID(), soap() { }
        virtual ~_ns1__getWeather() { }
        /// Friend allocator used by soap_new__ns1__getWeather(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getWeather * SOAP_FMAC2 soap_instantiate__ns1__getWeather(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:204 */
#ifndef SOAP_TYPE__ns1__getWeatherResponse
#define SOAP_TYPE__ns1__getWeatherResponse (21)
/* complex XSD type 'ns1:getWeatherResponse': */
class SOAP_CMAC _ns1__getWeatherResponse {
      public:
        /// Optional element 'ns1:getWeatherResult' of XSD type 'ns1:ArrayOfString'
        ns1__ArrayOfString *getWeatherResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__getWeatherResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__getWeatherResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__getWeatherResponse, default initialized and not managed by a soap context
        virtual _ns1__getWeatherResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__getWeatherResponse); }
      public:
        /// Constructor with initializations
        _ns1__getWeatherResponse() : getWeatherResult(), soap() { }
        virtual ~_ns1__getWeatherResponse() { }
        /// Friend allocator used by soap_new__ns1__getWeatherResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__getWeatherResponse * SOAP_FMAC2 soap_instantiate__ns1__getWeatherResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:207 */
#ifndef SOAP_TYPE__ns1__DataSet
#define SOAP_TYPE__ns1__DataSet (22)
/* complex XSD type 'ns1:DataSet': */
class SOAP_CMAC _ns1__DataSet {
      public:
        /// Required element 'xsd:schema' of XSD type 'xsd:anyType'
        char *xsd__schema;
        char *__any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DataSet
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__DataSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DataSet, default initialized and not managed by a soap context
        virtual _ns1__DataSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__DataSet); }
      public:
        /// Constructor with initializations
        _ns1__DataSet() : xsd__schema(), __any(), soap() { }
        virtual ~_ns1__DataSet() { }
        /// Friend allocator used by soap_new__ns1__DataSet(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DataSet * SOAP_FMAC2 soap_instantiate__ns1__DataSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:748 */
#ifndef SOAP_TYPE___ns1__getRegionDataset
#define SOAP_TYPE___ns1__getRegionDataset (35)
/* Wrapper: */
struct SOAP_CMAC __ns1__getRegionDataset {
      public:
        /** Optional element 'ns1:getRegionDataset' of XSD type 'ns1:getRegionDataset' */
        _ns1__getRegionDataset *ns1__getRegionDataset;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRegionDataset */
        long soap_type() const { return SOAP_TYPE___ns1__getRegionDataset; }
        /** Constructor with member initializations */
        __ns1__getRegionDataset() : ns1__getRegionDataset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getRegionDataset * SOAP_FMAC2 soap_instantiate___ns1__getRegionDataset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:820 */
#ifndef SOAP_TYPE___ns1__getRegionProvince
#define SOAP_TYPE___ns1__getRegionProvince (39)
/* Wrapper: */
struct SOAP_CMAC __ns1__getRegionProvince {
      public:
        /** Optional element 'ns1:getRegionProvince' of XSD type 'ns1:getRegionProvince' */
        _ns1__getRegionProvince *ns1__getRegionProvince;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRegionProvince */
        long soap_type() const { return SOAP_TYPE___ns1__getRegionProvince; }
        /** Constructor with member initializations */
        __ns1__getRegionProvince() : ns1__getRegionProvince() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getRegionProvince * SOAP_FMAC2 soap_instantiate___ns1__getRegionProvince(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:892 */
#ifndef SOAP_TYPE___ns1__getRegionCountry
#define SOAP_TYPE___ns1__getRegionCountry (43)
/* Wrapper: */
struct SOAP_CMAC __ns1__getRegionCountry {
      public:
        /** Optional element 'ns1:getRegionCountry' of XSD type 'ns1:getRegionCountry' */
        _ns1__getRegionCountry *ns1__getRegionCountry;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRegionCountry */
        long soap_type() const { return SOAP_TYPE___ns1__getRegionCountry; }
        /** Constructor with member initializations */
        __ns1__getRegionCountry() : ns1__getRegionCountry() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getRegionCountry * SOAP_FMAC2 soap_instantiate___ns1__getRegionCountry(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:964 */
#ifndef SOAP_TYPE___ns1__getSupportCityDataset
#define SOAP_TYPE___ns1__getSupportCityDataset (47)
/* Wrapper: */
struct SOAP_CMAC __ns1__getSupportCityDataset {
      public:
        /** Optional element 'ns1:getSupportCityDataset' of XSD type 'ns1:getSupportCityDataset' */
        _ns1__getSupportCityDataset *ns1__getSupportCityDataset;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getSupportCityDataset */
        long soap_type() const { return SOAP_TYPE___ns1__getSupportCityDataset; }
        /** Constructor with member initializations */
        __ns1__getSupportCityDataset() : ns1__getSupportCityDataset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getSupportCityDataset * SOAP_FMAC2 soap_instantiate___ns1__getSupportCityDataset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1036 */
#ifndef SOAP_TYPE___ns1__getSupportCityString
#define SOAP_TYPE___ns1__getSupportCityString (51)
/* Wrapper: */
struct SOAP_CMAC __ns1__getSupportCityString {
      public:
        /** Optional element 'ns1:getSupportCityString' of XSD type 'ns1:getSupportCityString' */
        _ns1__getSupportCityString *ns1__getSupportCityString;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getSupportCityString */
        long soap_type() const { return SOAP_TYPE___ns1__getSupportCityString; }
        /** Constructor with member initializations */
        __ns1__getSupportCityString() : ns1__getSupportCityString() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getSupportCityString * SOAP_FMAC2 soap_instantiate___ns1__getSupportCityString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1108 */
#ifndef SOAP_TYPE___ns1__getWeather
#define SOAP_TYPE___ns1__getWeather (55)
/* Wrapper: */
struct SOAP_CMAC __ns1__getWeather {
      public:
        /** Optional element 'ns1:getWeather' of XSD type 'ns1:getWeather' */
        _ns1__getWeather *ns1__getWeather;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getWeather */
        long soap_type() const { return SOAP_TYPE___ns1__getWeather; }
        /** Constructor with member initializations */
        __ns1__getWeather() : ns1__getWeather() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getWeather * SOAP_FMAC2 soap_instantiate___ns1__getWeather(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1180 */
#ifndef SOAP_TYPE___ns1__getRegionDataset_
#define SOAP_TYPE___ns1__getRegionDataset_ (57)
/* Wrapper: */
struct SOAP_CMAC __ns1__getRegionDataset_ {
      public:
        /** Optional element 'ns1:getRegionDataset' of XSD type 'ns1:getRegionDataset' */
        _ns1__getRegionDataset *ns1__getRegionDataset;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRegionDataset_ */
        long soap_type() const { return SOAP_TYPE___ns1__getRegionDataset_; }
        /** Constructor with member initializations */
        __ns1__getRegionDataset_() : ns1__getRegionDataset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getRegionDataset_ * SOAP_FMAC2 soap_instantiate___ns1__getRegionDataset_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1252 */
#ifndef SOAP_TYPE___ns1__getRegionProvince_
#define SOAP_TYPE___ns1__getRegionProvince_ (59)
/* Wrapper: */
struct SOAP_CMAC __ns1__getRegionProvince_ {
      public:
        /** Optional element 'ns1:getRegionProvince' of XSD type 'ns1:getRegionProvince' */
        _ns1__getRegionProvince *ns1__getRegionProvince;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRegionProvince_ */
        long soap_type() const { return SOAP_TYPE___ns1__getRegionProvince_; }
        /** Constructor with member initializations */
        __ns1__getRegionProvince_() : ns1__getRegionProvince() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getRegionProvince_ * SOAP_FMAC2 soap_instantiate___ns1__getRegionProvince_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1324 */
#ifndef SOAP_TYPE___ns1__getRegionCountry_
#define SOAP_TYPE___ns1__getRegionCountry_ (61)
/* Wrapper: */
struct SOAP_CMAC __ns1__getRegionCountry_ {
      public:
        /** Optional element 'ns1:getRegionCountry' of XSD type 'ns1:getRegionCountry' */
        _ns1__getRegionCountry *ns1__getRegionCountry;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getRegionCountry_ */
        long soap_type() const { return SOAP_TYPE___ns1__getRegionCountry_; }
        /** Constructor with member initializations */
        __ns1__getRegionCountry_() : ns1__getRegionCountry() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getRegionCountry_ * SOAP_FMAC2 soap_instantiate___ns1__getRegionCountry_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1396 */
#ifndef SOAP_TYPE___ns1__getSupportCityDataset_
#define SOAP_TYPE___ns1__getSupportCityDataset_ (63)
/* Wrapper: */
struct SOAP_CMAC __ns1__getSupportCityDataset_ {
      public:
        /** Optional element 'ns1:getSupportCityDataset' of XSD type 'ns1:getSupportCityDataset' */
        _ns1__getSupportCityDataset *ns1__getSupportCityDataset;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getSupportCityDataset_ */
        long soap_type() const { return SOAP_TYPE___ns1__getSupportCityDataset_; }
        /** Constructor with member initializations */
        __ns1__getSupportCityDataset_() : ns1__getSupportCityDataset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getSupportCityDataset_ * SOAP_FMAC2 soap_instantiate___ns1__getSupportCityDataset_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1468 */
#ifndef SOAP_TYPE___ns1__getSupportCityString_
#define SOAP_TYPE___ns1__getSupportCityString_ (65)
/* Wrapper: */
struct SOAP_CMAC __ns1__getSupportCityString_ {
      public:
        /** Optional element 'ns1:getSupportCityString' of XSD type 'ns1:getSupportCityString' */
        _ns1__getSupportCityString *ns1__getSupportCityString;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getSupportCityString_ */
        long soap_type() const { return SOAP_TYPE___ns1__getSupportCityString_; }
        /** Constructor with member initializations */
        __ns1__getSupportCityString_() : ns1__getSupportCityString() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getSupportCityString_ * SOAP_FMAC2 soap_instantiate___ns1__getSupportCityString_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1540 */
#ifndef SOAP_TYPE___ns1__getWeather_
#define SOAP_TYPE___ns1__getWeather_ (67)
/* Wrapper: */
struct SOAP_CMAC __ns1__getWeather_ {
      public:
        /** Optional element 'ns1:getWeather' of XSD type 'ns1:getWeather' */
        _ns1__getWeather *ns1__getWeather;
      public:
        /** Return unique type id SOAP_TYPE___ns1__getWeather_ */
        long soap_type() const { return SOAP_TYPE___ns1__getWeather_; }
        /** Constructor with member initializations */
        __ns1__getWeather_() : ns1__getWeather() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__getWeather_ * SOAP_FMAC2 soap_instantiate___ns1__getWeather_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* weather.h:1798 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (68)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* weather.h:1798 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (69)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* weather.h:1798 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (71)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* weather.h:1798 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (74)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* weather.h:1798 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (75)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* weather.h:157 */
#ifndef SOAP_TYPE__xsd__schema
#define SOAP_TYPE__xsd__schema (8)
typedef _XML _xsd__schema;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* _ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult has binding name '_ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult' for type '' */
#ifndef SOAP_TYPE__ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult
#define SOAP_TYPE__ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult (30)
#endif

/* _ns1__getRegionDatasetResponse_getRegionDatasetResult has binding name '_ns1__getRegionDatasetResponse_getRegionDatasetResult' for type '' */
#ifndef SOAP_TYPE__ns1__getRegionDatasetResponse_getRegionDatasetResult
#define SOAP_TYPE__ns1__getRegionDatasetResponse_getRegionDatasetResult (26)
#endif

/* std::wstring has binding name 'std__wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__wstring
#define SOAP_TYPE_std__wstring (23)
#endif

/* _ns1__DataSet has binding name '_ns1__DataSet' for type '' */
#ifndef SOAP_TYPE__ns1__DataSet
#define SOAP_TYPE__ns1__DataSet (22)
#endif

/* _ns1__getWeatherResponse has binding name '_ns1__getWeatherResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getWeatherResponse
#define SOAP_TYPE__ns1__getWeatherResponse (21)
#endif

/* _ns1__getWeather has binding name '_ns1__getWeather' for type '' */
#ifndef SOAP_TYPE__ns1__getWeather
#define SOAP_TYPE__ns1__getWeather (20)
#endif

/* _ns1__getSupportCityStringResponse has binding name '_ns1__getSupportCityStringResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getSupportCityStringResponse
#define SOAP_TYPE__ns1__getSupportCityStringResponse (19)
#endif

/* _ns1__getSupportCityString has binding name '_ns1__getSupportCityString' for type '' */
#ifndef SOAP_TYPE__ns1__getSupportCityString
#define SOAP_TYPE__ns1__getSupportCityString (18)
#endif

/* _ns1__getSupportCityDatasetResponse has binding name '_ns1__getSupportCityDatasetResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getSupportCityDatasetResponse
#define SOAP_TYPE__ns1__getSupportCityDatasetResponse (17)
#endif

/* _ns1__getSupportCityDataset has binding name '_ns1__getSupportCityDataset' for type '' */
#ifndef SOAP_TYPE__ns1__getSupportCityDataset
#define SOAP_TYPE__ns1__getSupportCityDataset (16)
#endif

/* _ns1__getRegionCountryResponse has binding name '_ns1__getRegionCountryResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getRegionCountryResponse
#define SOAP_TYPE__ns1__getRegionCountryResponse (15)
#endif

/* _ns1__getRegionCountry has binding name '_ns1__getRegionCountry' for type '' */
#ifndef SOAP_TYPE__ns1__getRegionCountry
#define SOAP_TYPE__ns1__getRegionCountry (14)
#endif

/* _ns1__getRegionProvinceResponse has binding name '_ns1__getRegionProvinceResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getRegionProvinceResponse
#define SOAP_TYPE__ns1__getRegionProvinceResponse (13)
#endif

/* _ns1__getRegionProvince has binding name '_ns1__getRegionProvince' for type '' */
#ifndef SOAP_TYPE__ns1__getRegionProvince
#define SOAP_TYPE__ns1__getRegionProvince (12)
#endif

/* _ns1__getRegionDatasetResponse has binding name '_ns1__getRegionDatasetResponse' for type '' */
#ifndef SOAP_TYPE__ns1__getRegionDatasetResponse
#define SOAP_TYPE__ns1__getRegionDatasetResponse (11)
#endif

/* _ns1__getRegionDataset has binding name '_ns1__getRegionDataset' for type '' */
#ifndef SOAP_TYPE__ns1__getRegionDataset
#define SOAP_TYPE__ns1__getRegionDataset (10)
#endif

/* ns1__ArrayOfString has binding name 'ns1__ArrayOfString' for type 'ns1:ArrayOfString' */
#ifndef SOAP_TYPE_ns1__ArrayOfString
#define SOAP_TYPE_ns1__ArrayOfString (9)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (75)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (74)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (71)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (69)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (68)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (77)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (76)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (70)
#endif

/* _ns1__getWeather * has binding name 'PointerTo_ns1__getWeather' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getWeather
#define SOAP_TYPE_PointerTo_ns1__getWeather (52)
#endif

/* _ns1__getSupportCityString * has binding name 'PointerTo_ns1__getSupportCityString' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getSupportCityString
#define SOAP_TYPE_PointerTo_ns1__getSupportCityString (48)
#endif

/* _ns1__getSupportCityDataset * has binding name 'PointerTo_ns1__getSupportCityDataset' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getSupportCityDataset
#define SOAP_TYPE_PointerTo_ns1__getSupportCityDataset (44)
#endif

/* _ns1__getRegionCountry * has binding name 'PointerTo_ns1__getRegionCountry' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getRegionCountry
#define SOAP_TYPE_PointerTo_ns1__getRegionCountry (40)
#endif

/* _ns1__getRegionProvince * has binding name 'PointerTo_ns1__getRegionProvince' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getRegionProvince
#define SOAP_TYPE_PointerTo_ns1__getRegionProvince (36)
#endif

/* _ns1__getRegionDataset * has binding name 'PointerTo_ns1__getRegionDataset' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getRegionDataset
#define SOAP_TYPE_PointerTo_ns1__getRegionDataset (32)
#endif

/* _ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult * has binding name 'PointerTo_ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult
#define SOAP_TYPE_PointerTo_ns1__getSupportCityDatasetResponse_getSupportCityDatasetResult (31)
#endif

/* std::wstring * has binding name 'PointerTostd__wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__wstring
#define SOAP_TYPE_PointerTostd__wstring (29)
#endif

/* ns1__ArrayOfString * has binding name 'PointerTons1__ArrayOfString' for type 'ns1:ArrayOfString' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfString
#define SOAP_TYPE_PointerTons1__ArrayOfString (28)
#endif

/* _ns1__getRegionDatasetResponse_getRegionDatasetResult * has binding name 'PointerTo_ns1__getRegionDatasetResponse_getRegionDatasetResult' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__getRegionDatasetResponse_getRegionDatasetResult
#define SOAP_TYPE_PointerTo_ns1__getRegionDatasetResponse_getRegionDatasetResult (27)
#endif

/* _xsd__schema has binding name '_xsd__schema' for type '' */
#ifndef SOAP_TYPE__xsd__schema
#define SOAP_TYPE__xsd__schema (8)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<std::wstring>  has binding name 'std__vectorTemplateOfstd__wstring' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__wstring
#define SOAP_TYPE_std__vectorTemplateOfstd__wstring (24)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
